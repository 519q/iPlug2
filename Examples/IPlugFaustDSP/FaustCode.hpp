/* ------------------------------------------------------------
name: "FaustExample"
Code generated with Faust 2.27.0 (https://faust.grame.fr)
Compilation options: -lang cpp -scal -ftz 0
------------------------------------------------------------ */

#ifndef  __Faust1_H__
#define  __Faust1_H__


#include "IPlugFaust.h"

/* BEGIN AUTO GENERATED BY THE FAUST COMPILER ... */
#ifndef FAUSTFLOAT
#define FAUSTFLOAT float
#endif 

#include <algorithm>
#include <cmath>
#include <math.h>


#ifndef FAUSTCLASS 
#define FAUSTCLASS Faust1
#endif

#ifdef __APPLE__ 
#define exp10f __exp10f
#define exp10 __exp10
#endif

class Faust1 : public dsp {
	
 private:
	
	FAUSTFLOAT fHslider0;
	FAUSTFLOAT fHslider1;
	int fSampleRate;
	float fConst0;
	float fConst1;
	FAUSTFLOAT fHslider2;
	float fRec0[2];
	float fConst2;
	float fConst3;
	FAUSTFLOAT fButton0;
	float fVec0[2];
	float fRec2[2];
	float fConst4;
	float fConst5;
	int iRec3[2];
	
 public:
	
	void metadata(Meta* m) { 
		m->declare("envelopes.lib/adsr:author", "Yann Orlarey");
		m->declare("envelopes.lib/author", "GRAME");
		m->declare("envelopes.lib/copyright", "GRAME");
		m->declare("envelopes.lib/license", "LGPL with exception");
		m->declare("envelopes.lib/name", "Faust Envelope Library");
		m->declare("envelopes.lib/version", "0.1");
		m->declare("filename", "IPlugFaustDSP.dsp");
		m->declare("maths.lib/author", "GRAME");
		m->declare("maths.lib/copyright", "GRAME");
		m->declare("maths.lib/license", "LGPL with exception");
		m->declare("maths.lib/name", "Faust Math Library");
		m->declare("maths.lib/version", "2.3");
		m->declare("name", "FaustExample");
		m->declare("options", "[midi:on][nvoices:12]");
		m->declare("oscillators.lib/name", "Faust Oscillator Library");
		m->declare("oscillators.lib/version", "0.1");
		m->declare("platform.lib/name", "Generic Platform Library");
		m->declare("platform.lib/version", "0.1");
	}

	virtual int getNumInputs() {
		return 0;
	}
	virtual int getNumOutputs() {
		return 2;
	}
	virtual int getInputRate(int channel) {
		int rate;
		switch ((channel)) {
			default: {
				rate = -1;
				break;
			}
		}
		return rate;
	}
	virtual int getOutputRate(int channel) {
		int rate;
		switch ((channel)) {
			case 0: {
				rate = 1;
				break;
			}
			case 1: {
				rate = 1;
				break;
			}
			default: {
				rate = -1;
				break;
			}
		}
		return rate;
	}
	
	static void classInit(int sample_rate) {
	}
	
	virtual void instanceConstants(int sample_rate) {
		fSampleRate = sample_rate;
		fConst0 = std::min<float>(192000.0f, std::max<float>(1.0f, float(fSampleRate)));
		fConst1 = (1.0f / fConst0);
		fConst2 = std::max<float>(1.0f, (0.00999999978f * fConst0));
		fConst3 = (1.0f / fConst2);
		fConst4 = (0.200000003f / fConst2);
		fConst5 = (0.800000012f / std::max<float>(1.0f, (0.100000001f * fConst0)));
	}
	
	virtual void instanceResetUserInterface() {
		fHslider0 = FAUSTFLOAT(0.5f);
		fHslider1 = FAUSTFLOAT(0.5f);
		fHslider2 = FAUSTFLOAT(200.0f);
		fButton0 = FAUSTFLOAT(0.0f);
	}
	
	virtual void instanceClear() {
		for (int l0 = 0; (l0 < 2); l0 = (l0 + 1)) {
			fRec0[l0] = 0.0f;
		}
		for (int l1 = 0; (l1 < 2); l1 = (l1 + 1)) {
			fVec0[l1] = 0.0f;
		}
		for (int l2 = 0; (l2 < 2); l2 = (l2 + 1)) {
			fRec2[l2] = 0.0f;
		}
		for (int l3 = 0; (l3 < 2); l3 = (l3 + 1)) {
			iRec3[l3] = 0;
		}
	}
	
	virtual void init(int sample_rate) {
		classInit(sample_rate);
		instanceInit(sample_rate);
	}
	virtual void instanceInit(int sample_rate) {
		instanceConstants(sample_rate);
		instanceResetUserInterface();
		instanceClear();
	}
	
	virtual Faust1* clone() {
		return new Faust1();
	}
	
	virtual int getSampleRate() {
		return fSampleRate;
	}
	
	virtual void buildUserInterface(UI* ui_interface) {
		ui_interface->openVerticalBox("FaustExample");
		ui_interface->addHorizontalSlider("freq", &fHslider2, 200.0f, 50.0f, 1000.0f, 0.00999999978f);
		ui_interface->addHorizontalSlider("gain", &fHslider0, 0.5f, 0.0f, 1.0f, 0.00999999978f);
		ui_interface->addButton("gate", &fButton0);
		ui_interface->declare(&fHslider1, "midi", "ctrl 7");
		ui_interface->addHorizontalSlider("master", &fHslider1, 0.5f, 0.0f, 1.0f, 0.00999999978f);
		ui_interface->closeBox();
	}
	
	virtual void compute(int count, FAUSTFLOAT** inputs, FAUSTFLOAT** outputs) {
		FAUSTFLOAT* output0 = outputs[0];
		FAUSTFLOAT* output1 = outputs[1];
		float fSlow0 = (float(fHslider0) * float(fHslider1));
		float fSlow1 = std::max<float>(1.00000001e-07f, std::fabs(float(fHslider2)));
		float fSlow2 = (fConst1 * fSlow1);
		float fSlow3 = (1.0f - (fConst0 / fSlow1));
		float fSlow4 = float(fButton0);
		int iSlow5 = (fSlow4 == 0.0f);
		for (int i = 0; (i < count); i = (i + 1)) {
			float fTemp0 = (fSlow2 + (fRec0[1] + -1.0f));
			int iTemp1 = (fTemp0 < 0.0f);
			float fTemp2 = (fSlow2 + fRec0[1]);
			fRec0[0] = (iTemp1 ? fTemp2 : fTemp0);
			float fRec1 = (iTemp1 ? fTemp2 : (fSlow2 + (fRec0[1] + (fSlow3 * fTemp0))));
			fVec0[0] = fSlow4;
			fRec2[0] = (fSlow4 + (fRec2[1] * float((fVec0[1] >= fSlow4))));
			iRec3[0] = (iSlow5 * (iRec3[1] + 1));
			float fTemp3 = (fSlow0 * (((2.0f * fRec1) + -1.0f) * std::max<float>(0.0f, (std::min<float>((fConst3 * fRec2[0]), std::max<float>((1.20000005f - (fConst4 * fRec2[0])), 0.800000012f)) - (fConst5 * float(iRec3[0]))))));
			output0[i] = FAUSTFLOAT(fTemp3);
			output1[i] = FAUSTFLOAT(fTemp3);
			fRec0[1] = fRec0[0];
			fVec0[1] = fVec0[0];
			fRec2[1] = fRec2[0];
			iRec3[1] = iRec3[0];
		}
	}

};
/* ... END AUTO GENERATED BY THE FAUST COMPILER  */

using namespace iplug;

class Faust_Faust1 : public IPlugFaust
{
public:
  Faust_Faust1(const char* name,
              const char* inputDSPFile = 0,
              int nVoices = 1,
              int rate = 1,
              const char* outputCPPFile = 0,
              const char* drawPath = 0,
              const char* libraryPath = FAUST_LIBRARY_PATH)
  : IPlugFaust(name, nVoices)
  {
  }

  void Init() override
  {
    mMidiHandler = std::make_unique<iplug2_midi_handler>();
    mMidiUI = std::make_unique<MidiUI>(mMidiHandler.get());
      
    ::dsp* tmpDsp = new FAUSTCLASS();
    
    // Polyphony handling
    bool midiSync = false;
    int nvoices = 0;
    MidiMeta::analyse(tmpDsp, midiSync, nvoices);
    
    if (nvoices > 0)
    {
      dsp_poly* dspPoly = new FAUSTCLASS_POLY(tmpDsp, nvoices, true);
      mMidiHandler->addMidiIn(dspPoly);
      mDSP = std::unique_ptr<::dsp>(dspPoly);
    }
    else
    {
      mDSP = std::unique_ptr<::dsp>(tmpDsp);
    }
    
    // MIDI handling
    mDSP->buildUserInterface(mMidiUI.get());
    mDSP->buildUserInterface(this);
    
    BuildParameterMap();
    
    mInitialized = true;
  }
};

#undef FAUSTCLASS


#endif
