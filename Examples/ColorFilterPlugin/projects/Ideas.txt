
dc sine osc

foldback shaper for feedback osc

class ReflectShaper *
{
public:
  double Process(double input, FilterParameters& params)
  {
    double threshold = SpectShape;

    // If the knob is below the processing floor, return the input unchanged
    if (threshold < processingFloor)
      return input;

    // Compute the absolute value of the input for reflection
    double absInput = std::abs(input);

    // If the input is within the threshold, return it unchanged
    if (absInput <= threshold)
      return input;

    // Apply foldback reflection
    double folded = std::fmod(absInput, 2.0 * threshold);
    if (folded > threshold)
      folded = 2.0 * threshold - folded;

    // Restore the original sign of the input
    folded = (input >= 0.0) ? folded : -folded;

    return folded;
  }
};


double SpectralShaper::morphSine(double phase, FilterParameters& params)
{
    // shapeParam controls the shape:
    // - shapeParam = 0: Sine wave
    // - shapeParam = 1: Square-like wave

    // Add odd harmonics
    double sine = std::sin(phase);
    double thirdHarmonic = std::sin(3.0 * phase) / 3.0;
    double fifthHarmonic = std::sin(5.0 * phase) / 5.0;

    // Blend harmonics based on shapeParam
    double shaped = sine + params.m_SH_shape * (thirdHarmonic + fifthHarmonic);

    // Normalize to ensure the output is in [-1, 1]
    double maxAmplitude = 1.0 + params.m_SH_shape * (1.0 / 3.0 + 1.0 / 5.0); // Max amplitude for sine = 1
    shaped /= maxAmplitude;

    return shaped;
}
SHAPERS


Example: Cubic Shaping
cpp
double shapeCubic(double sineValue, double drive)
{
    // Cubic soft clipping
    double shapedValue = sineValue - (1.0 / 3.0) * std::pow(sineValue, 3);
    return shapedValue * drive;
}

Example: Polynomial Shaping
cpp
double shapePolynomial(double sineValue, double drive)
{
    // Polynomial shaping (adjust coefficients for different curves)
    double shapedValue = sineValue - 0.2 * std::pow(sineValue, 3) + 0.1 * std::pow(sineValue, 5);
    return shapedValue * drive;
}

2. Asymmetric Shaping
Asymmetric shaping introduces even-order harmonics, which can create a warmer, more "inflated" sound.

Example: Asymmetric Tanh
cpp
double shapeAsymmetricTanh(double sineValue, double drive)
{
    // Asymmetric tanh shaping
    double shapedValue = std::tanh(drive * sineValue) + 0.5 * std::tanh(0.5 * drive * sineValue);
    return shapedValue;
}

Exponential shaping can create a more aggressive, "square-like" sound.

Example: Exponential Shaping
cpp
double shapeExponential(double sineValue, double drive)
{
    // Exponential shaping
    double shapedValue = std::exp(drive * sineValue) - 1.0;
    return shapedValue / (std::exp(drive) - 1.0); // Normalize
}

Foldback distortion creates a "folded" waveform, which can add complex harmonics.

Example: Foldback Distortion
cpp
double shapeFoldback(double sineValue, double threshold)
{
    // Foldback distortion
    if (sineValue > threshold || sineValue < -threshold)
    {
        sineValue = std::fmod(sineValue + threshold, 4.0 * threshold) - 2.0 * threshold;
    }
    return sineValue;
}

5. Wavefolding
Wavefolding is similar to foldback distortion but creates a smoother, more complex waveform.

Example: Wavefolding
cpp
double shapeWavefold(double sineValue, double drive)
{
    // Wavefolding
    double shapedValue = std::sin(drive * sineValue);
    return shapedValue;
}

6. Chebyshev Polynomials
Chebyshev polynomials are often used in wave-shaping to create specific harmonic content.

Example: Chebyshev Polynomial
cpp
double shapeChebyshev(double sineValue, double drive)
{
    // Chebyshev polynomial (3rd order)
    double shapedValue = 4.0 * std::pow(sineValue, 3) - 3.0 * sineValue;
    return shapedValue * drive;
}

8. Dynamic Shaping
You can dynamically adjust the shaping function based on the input amplitude or other parameters.

Example: Dynamic Shaping
cpp
Copy
double shapeDynamic(double sineValue, double drive, double amplitude)
{
    // Adjust drive based on input amplitude
    double adjustedDrive = drive * (1.0 + 0.5 * amplitude);
    return std::tanh(adjustedDrive * sineValue);
}

*******************************************************************************

2. Applying a DC Offset
To apply a DC offset without clipping, you need to scale the signal so that the maximum value after adding the offset does not exceed the allowable range (e.g., [-1, 1] for normalized audio signals).

Implementation
cpp
double DomeShaper::applyDCOffset(double sineValue, double dcOffset)
{
  // Scale the sine value to avoid clipping
  double scaleFactor = 1.0 - std::abs(dcOffset);
  return dcOffset + scaleFactor * sineValue;
}
Usage
cpp
double DomeShaper::generateCustomSinusoid(double freq, double time, double phase, double shapeAmount, double dcOffset)
{
  double sineValue = std::cos(2.0 * iplug::PI * freq * time + phase);
  double shapedValue = shapeSine(sineValue, shapeAmount);
  return applyDCOffset(shapedValue, dcOffset);
}

3. Introducing a Delay
To introduce a delay (e.g., up to 5 ms), you can use a ring buffer or delay line to store the signal and retrieve it after the desired delay.

Implementation
cpp
class DelayLine
{
private:
  std::vector<double> buffer;
  size_t writeIndex = 0;
  size_t delaySamples = 0;

public:
  DelayLine(size_t maxDelaySamples)
  {
    buffer.resize(maxDelaySamples, 0.0);
  }

  void setDelay(size_t delaySamples)
  {
    this->delaySamples = delaySamples;
  }

  double process(double input)
  {
    // Read the delayed sample
    size_t readIndex = (writeIndex - delaySamples + buffer.size()) % buffer.size();
    double output = buffer[readIndex];

    // Write the new sample
    buffer[writeIndex] = input;
    writeIndex = (writeIndex + 1) % buffer.size();

    return output;
  }
};
Usage
cpp
class DomeShaper
{
private:
  DelayLine delayLine;

public:
  DomeShaper(size_t maxDelaySamples) : delayLine(maxDelaySamples) {}

  void setDelay(double delayMs, double sampleRate)
  {
    size_t delaySamples = static_cast<size_t>(delayMs * sampleRate / 1000.0);
    delayLine.setDelay(delaySamples);
  }

  double generateCustomSinusoid(double freq, double time, double phase, double shapeAmount, double dcOffset)
  {
    double sineValue = std::cos(2.0 * iplug::PI * freq * time + phase);
    double shapedValue = shapeSine(sineValue, shapeAmount);
    double offsetValue = applyDCOffset(shapedValue, dcOffset);
    return delayLine.process(offsetValue);
  }
};
****************************************

SCALING

- Cubic Scaling:
     
     double scaled_t = std::pow(t, 3);

   - Exponential Scaling:
     
     double k = 2.0; // Steepness factor
     double scaled_t = (std::exp(k * t) - 1.0) / (std::exp(k) - 1.0);

   - Logarithmic Scaling:
     
     double a = 9.0; // Controls the curve
     double scaled_t = std::log1p(a * t) / std::log1p(a);

     example:  std::pow(param, 2)

     TanhShaper() : processingFloor(0.1), maxGain(5.0), maxOutputScaling(3.5) {}

       double Process(double input, FilterParameters& params)
       {
           if (params.m_SH_shape < processingFloor)
               return input;

           double t = params.m_SH_shape; // Knob position [0, 1]

           // Apply quadratic (non-linear) scaling to smooth out loudness increase
           double scaled_t = std::pow(t, 2); // Adjust exponent as needed

           // Calculate the scaling factors
           double inputScaling = 1.0 + scaled_t * (maxGain - 1.0);          // [1, maxGain]
           double outputScaling = 1.0 + scaled_t * (maxOutputScaling - 1.0); // [1, maxOutputScaling]

           // Scale the input signal
           double inputProcess = input * inputScaling;

           // Apply the tanh shaping
           double shaped = std::tanh(inputProcess);

           // Scale the shaped signal to control overall gain
           double output = shaped / outputScaling;

           // Optional: Prevent clipping by ensuring the output stays within [-1, 1]
           output = std::clamp(output, -1.0, 1.0);

           return output;
       }

   private:
       double processingFloor;
       const double maxGain;          // Maximum input scaling factor
       const double maxOutputScaling; // Maximum output scaling factor
   };


*****************************************************************************


FFT PROCESSING                        

// Working approaches for FFT manipulation:

// 1. Magnitude/phase modification
void manipulateSpectrum(std::vector<std::complex<float>>& spectrum) {
    for(int i = 0; i < spectrum.size(); i++) {
        float magnitude = std::abs(spectrum[i]);
        float phase = std::arg(spectrum[i]);
        
        // These work well:
        magnitude *= 2.0f;                    // Gain
        magnitude = std::pow(magnitude, 1.5f); // Compression
        phase += 0.1f;                        // Phase shift
        
        spectrum[i] = std::polar(magnitude, phase);
    }
}

// 2. Frequency shifting/scaling
void frequencyShift(std::vector<std::complex<float>>& spectrum) {
    // Move bins up/down
    int shift = 1;
    std::rotate(spectrum.begin(), 
                spectrum.begin() + shift, 
                spectrum.end());
}

// 3. Spectral filtering
void spectralFilter(std::vector<std::complex<float>>& spectrum) {
    // Multiply by filter response
    for(int i = 0; i < spectrum.size(); i++) {
        float freq = i * sampleRate / fftSize;
        float response = calculateFilterResponse(freq);
        spectrum[i] *= response;
    }
}


For more complex transformations, you might want to:

// 1. Use analysis-synthesis approach
class SpectralProcessor {
    void process(const float* input, float* output) {
        // 1. Analysis
        std::vector<float> magnitude(fftSize/2);
        std::vector<float> phase(fftSize/2);
        analyzeFrame(input, magnitude, phase);
        
        // 2. Transform magnitude/phase separately
        transformMagnitude(magnitude);  // This works well
        transformPhase(phase);         // This works well
        
        // 3. Resynthesize
        synthesizeFrame(magnitude, phase, output);
    }
};

// 2. Use multiple parallel FFT streams
class MultiStreamProcessor {
    std::vector<FFTStream> streams;
    
    void process() {
        // Process each stream separately
        for(auto& stream : streams) {
            stream.analyze();
            stream.transform();
            stream.synthesize();
        }
        
        // Mix streams back together
        mixStreams();
    }
};

// 3. Use phase vocoder techniques
class PhaseVocoder {
    void process() {
        // Track phase progression
        analyzePhaseDerivative();
        
        // Modify time/pitch independently
        stretchTime(2.0);    // This works
        shiftPitch(1.5);     // This works
        
        // Preserve phase coherence
        synthesizeWithPhaseCorrection();
    }
};


For "Bitwig-like" effects, you might want:

class SpectralEffects {
    // 1. Frequency-dependent processing
    void spectralShaper() {
        for(int bin = 0; bin < numBins; bin++) {
            float freq = binToFreq(bin);
            float amount = shapeAmount * (freq / nyquist);
            magnitudes[bin] = transform(magnitudes[bin], amount);
        }
    }
    
    // 2. Bin relationship processing
    void spectralEnhancer() {
        for(int bin = 0; bin < numBins-1; bin++) {
            // Compare adjacent bins
            float ratio = magnitudes[bin+1] / magnitudes[bin];
            if(ratio > threshold) {
                // Enhance spectral peaks
                magnitudes[bin] *= emphasis;
            }
        }
    }
    
    // 3. Time-coherent processing
    void coherentTransform() {
        // Track bin evolution over time
        trackPeaks();
        // Apply transformations that preserve motion
        transformTrajectories();
    }
};


Key points:
1. Direct time-domain effects don't work well in FFT domain
2. Focus on magnitude/phase relationships
3. Consider using multiple processing streams
4. Preserve phase coherence for natural sound
5. Use frequency-dependent processing
6. Track spectral evolution over time

For your specific goals:
1. If you want waveshaping-like effects, apply them to magnitude spectrum
2. For harmonic manipulation, work with bin relationships
3. Consider using phase vocoder for more complex transformations
4. Multiple parallel FFT streams can help with time-varying effects

Remember: FFT processing is about relationships between frequencies, not direct waveform manipulation. Think in terms of spectral transformations rather than time-domain effects.

